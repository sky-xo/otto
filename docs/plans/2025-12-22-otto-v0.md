# Otto V0 Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Ship a Seed/V0 `otto` CLI that can spawn agents, persist state in SQLite, and support core messaging workflows without daemon or worktree support.

**Architecture:** A Go CLI (Cobra) writes/reads from a per-orchestrator SQLite DB in `~/.otto/` (versionless for V0) and shells out to `claude`/`codex` for agent execution. Orchestrator scope is derived from git repo + branch, and all state is managed through small repository helpers.

**Tech Stack:** Go, Cobra, modernc.org/sqlite (pure Go SQLite), os/exec

---

### Task 1: Bootstrap Go module + base CLI + data-dir helper

**Files:**
- Create: `go.mod`
- Create: `cmd/otto/main.go`
- Create: `internal/cli/root.go`
- Create: `internal/config/paths.go`
- Create: `internal/config/paths_test.go`

**Step 1: Write the failing test**

```go
package config

import (
    "os"
    "path/filepath"
    "testing"
)

func TestDataDir_DefaultsToHomeOtto(t *testing.T) {
    t.Setenv("HOME", "/tmp/otto-home")
    got := DataDir()
    want := filepath.Join("/tmp/otto-home", ".otto")
    if got != want {
        t.Fatalf("expected %q, got %q", want, got)
    }
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./...`
Expected: FAIL (package not found or DataDir undefined)

**Step 3: Write minimal implementation**

```go
package config

import (
    "os"
    "path/filepath"
)

func DataDir() string {
    if home := os.Getenv("HOME"); home != "" {
        return filepath.Join(home, ".otto")
    }
    home, _ := os.UserHomeDir()
    if home == "" {
        return ".otto"
    }
    return filepath.Join(home, ".otto")
}
```

Also add a minimal Cobra root:

```go
// cmd/otto/main.go
package main

import "otto/internal/cli"

func main() {
    cli.Execute()
}
```

```go
// internal/cli/root.go
package cli

import "github.com/spf13/cobra"

func Execute() {
    rootCmd := &cobra.Command{Use: "otto"}
    _ = rootCmd.Execute()
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./...`
Expected: PASS

**Step 5: Commit**

```bash
go mod tidy
git add go.mod go.sum cmd/otto/main.go internal/cli/root.go internal/config/paths.go internal/config/paths_test.go
git commit -m "chore: bootstrap go module and cli"
```

---

### Task 2: SQLite DB open + schema creation

**Files:**
- Create: `internal/db/db.go`
- Create: `internal/db/schema.sql`
- Create: `internal/db/db_test.go`

**Step 1: Write the failing test**

```go
package db

import (
    "database/sql"
    "os"
    "path/filepath"
    "testing"
)

func TestEnsureSchema(t *testing.T) {
    dir := t.TempDir()
    path := filepath.Join(dir, "otto.db")

    conn, err := Open(path)
    if err != nil {
        t.Fatalf("open: %v", err)
    }
    defer conn.Close()

    if _, err := conn.Query("SELECT name FROM sqlite_master WHERE type='table' AND name='agents'"); err != nil {
        t.Fatalf("query agents: %v", err)
    }

    if _, err := conn.Query("SELECT name FROM sqlite_master WHERE type='table' AND name='messages'"); err != nil {
        t.Fatalf("query messages: %v", err)
    }
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./...`
Expected: FAIL (Open undefined, schema missing)

**Step 3: Write minimal implementation**

```go
package db

import (
    "database/sql"
    _ "modernc.org/sqlite"
    "os"
)

const schemaSQL = `-- agents table
CREATE TABLE IF NOT EXISTS agents (
  id TEXT PRIMARY KEY,
  type TEXT NOT NULL,
  task TEXT NOT NULL,
  status TEXT NOT NULL,
  session_id TEXT,
  worktree_path TEXT,
  branch_name TEXT,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- messages table
CREATE TABLE IF NOT EXISTS messages (
  id TEXT PRIMARY KEY,
  from_id TEXT NOT NULL,
  type TEXT NOT NULL,
  content TEXT NOT NULL,
  mentions TEXT,
  requires_human BOOLEAN DEFAULT FALSE,
  read_by TEXT DEFAULT '[]',
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_messages_created ON messages(created_at);
CREATE INDEX IF NOT EXISTS idx_agents_status ON agents(status);
`

func Open(path string) (*sql.DB, error) {
    conn, err := sql.Open("sqlite", path)
    if err != nil {
        return nil, err
    }
    if err := ensureSchema(conn); err != nil {
        _ = conn.Close()
        return nil, err
    }
    return conn, nil
}

func ensureSchema(conn *sql.DB) error {
    _, err := conn.Exec(schemaSQL)
    return err
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./...`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/db/db.go internal/db/schema.sql internal/db/db_test.go
git commit -m "feat: add sqlite schema and db open"
```

---

### Task 3: Orchestrator scope + DB path resolution

**Files:**
- Create: `internal/scope/scope.go`
- Create: `internal/scope/scope_test.go`
- Create: `internal/scope/git.go`

**Step 1: Write the failing test**

```go
package scope

import "testing"

func TestScopeFromRepoAndBranch(t *testing.T) {
    got := Scope("/Users/alice/code/my-app", "feature-auth")
    want := "my-app/feature-auth"
    if got != want {
        t.Fatalf("expected %q, got %q", want, got)
    }
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./...`
Expected: FAIL (Scope undefined)

**Step 3: Write minimal implementation**

```go
package scope

import "path/filepath"

func Scope(repoRoot, branch string) string {
    project := filepath.Base(repoRoot)
    if branch == "" {
        return project
    }
    return project + "/" + branch
}
```

Add git detection helpers:

```go
package scope

import "os/exec"

// RepoRoot returns git repo root or empty string if not in a git repo.
func RepoRoot() string {
    // Run: git rev-parse --show-toplevel
    // Return empty string on error.
}

// BranchName returns current branch or empty string if not in a git repo.
func BranchName() string {
    // Run: git rev-parse --abbrev-ref HEAD
    // Return empty string on error.
}
```

Fallback behavior:
- If git is unavailable, use `os.Getwd()` basename as repo root.
- Default branch name to `main` when missing.

**Step 4: Run test to verify it passes**

Run: `go test ./...`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/scope/scope.go internal/scope/scope_test.go internal/scope/git.go
git commit -m "feat: add orchestrator scope helper"
```

---

### Task 4: Agent repository (create/update/list)

**Files:**
- Create: `internal/repo/agents.go`
- Create: `internal/repo/agents_test.go`

**Step 1: Write the failing test**

```go
package repo

import (
    "testing"
)

func TestAgentsCRUD(t *testing.T) {
    db := openTestDB(t)

    err := CreateAgent(db, Agent{ID: "authbackend", Type: "claude", Task: "design", Status: "working"})
    if err != nil {
        t.Fatalf("create: %v", err)
    }

    if err := UpdateAgentStatus(db, "authbackend", "done"); err != nil {
        t.Fatalf("update: %v", err)
    }

    agents, err := ListAgents(db)
    if err != nil {
        t.Fatalf("list: %v", err)
    }
    if len(agents) != 1 || agents[0].Status != "done" {
        t.Fatalf("unexpected agents: %#v", agents)
    }

    if _, err := GetAgent(db, "authbackend"); err != nil {
        t.Fatalf("get: %v", err)
    }
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./...`
Expected: FAIL (CreateAgent undefined)

**Step 3: Write minimal implementation**

```go
package repo

import (
    "database/sql"
    "encoding/json"
)

type Agent struct {
    ID        string
    Type      string
    Task      string
    Status    string
    SessionID sql.NullString
}

func CreateAgent(db *sql.DB, a Agent) error {
    _, err := db.Exec(`INSERT INTO agents (id, type, task, status, session_id) VALUES (?, ?, ?, ?, ?)`, a.ID, a.Type, a.Task, a.Status, a.SessionID)
    return err
}

func GetAgent(db *sql.DB, id string) (Agent, error) {
    var a Agent
    err := db.QueryRow(`SELECT id, type, task, status, session_id FROM agents WHERE id = ?`, id).
        Scan(&a.ID, &a.Type, &a.Task, &a.Status, &a.SessionID)
    return a, err
}

func UpdateAgentStatus(db *sql.DB, id, status string) error {
    _, err := db.Exec(`UPDATE agents SET status = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?`, status, id)
    return err
}

func ListAgents(db *sql.DB) ([]Agent, error) {
    rows, err := db.Query(`SELECT id, type, task, status, session_id FROM agents ORDER BY created_at ASC`)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    var out []Agent
    for rows.Next() {
        var a Agent
        if err := rows.Scan(&a.ID, &a.Type, &a.Task, &a.Status, &a.SessionID); err != nil {
            return nil, err
        }
        out = append(out, a)
    }
    return out, rows.Err()
}
```

Also add a shared test helper in `internal/repo/agents_test.go`:

```go
func openTestDB(t *testing.T) *sql.DB {
    t.Helper()
    path := filepath.Join(t.TempDir(), "otto.db")
    conn, err := db.Open(path)
    if err != nil {
        t.Fatalf("open: %v", err)
    }
    return conn
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./...`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/repo/agents.go internal/repo/agents_test.go
git commit -m "feat: add agent repository"
```

---

### Task 5: Message repository (create/list/filter)

**Files:**
- Create: `internal/repo/messages.go`
- Create: `internal/repo/messages_test.go`

**Step 1: Write the failing test**

```go
package repo

import "testing"

func TestMessagesFilterByType(t *testing.T) {
    db := openTestDB(t)

    _ = CreateMessage(db, Message{ID: "m1", FromID: "agent-1", Type: "say", Content: "hello"})
    _ = CreateMessage(db, Message{ID: "m2", FromID: "agent-1", Type: "question", Content: "help"})

    msgs, err := ListMessages(db, MessageFilter{Type: "question"})
    if err != nil {
        t.Fatalf("list: %v", err)
    }
    if len(msgs) != 1 || msgs[0].ID != "m2" {
        t.Fatalf("unexpected messages: %#v", msgs)
    }
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./...`
Expected: FAIL (CreateMessage undefined)

**Step 3: Write minimal implementation**

```go
package repo

import "database/sql"

type Message struct {
    ID            string
    FromID        string
    Type          string
    Content       string
    MentionsJSON  string
    RequiresHuman bool
    ReadByJSON    string
}

type MessageFilter struct {
    Type   string
    FromID string
    Limit  int
    Mention string
    ReaderID string
}

func CreateMessage(db *sql.DB, m Message) error {
    _, err := db.Exec(`INSERT INTO messages (id, from_id, type, content, mentions, requires_human, read_by) VALUES (?, ?, ?, ?, ?, ?, ?)`, m.ID, m.FromID, m.Type, m.Content, m.MentionsJSON, m.RequiresHuman, m.ReadByJSON)
    return err
}

func ListMessages(db *sql.DB, f MessageFilter) ([]Message, error) {
    query := `SELECT id, from_id, type, content, mentions, requires_human, read_by FROM messages`
    var args []interface{}
    where := ""
    if f.Type != "" {
        where = appendWhere(where, "type = ?")
        args = append(args, f.Type)
    }
    if f.FromID != "" {
        where = appendWhere(where, "from_id = ?")
        args = append(args, f.FromID)
    }
    if where != "" {
        query += " WHERE " + where
    }
    query += " ORDER BY created_at ASC"
    if f.Limit > 0 {
        query += " LIMIT ?"
        args = append(args, f.Limit)
    }

    rows, err := db.Query(query, args...)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    var out []Message
    for rows.Next() {
        var m Message
        if err := rows.Scan(&m.ID, &m.FromID, &m.Type, &m.Content, &m.MentionsJSON, &m.RequiresHuman, &m.ReadByJSON); err != nil {
            return nil, err
        }
        if f.Mention != "" && !mentionsContain(m.MentionsJSON, f.Mention) {
            continue
        }
        if f.ReaderID != "" && readByContains(m.ReadByJSON, f.ReaderID) {
            continue
        }
        out = append(out, m)
    }
    return out, rows.Err()
}

func appendWhere(existing, clause string) string {
    if existing == "" {
        return clause
    }
    return existing + " AND " + clause
}

func mentionsContain(mentionsJSON, mention string) bool {
    var items []string
    if err := json.Unmarshal([]byte(mentionsJSON), &items); err != nil {
        return false
    }
    for _, item := range items {
        if item == mention {
            return true
        }
    }
    return false
}

func readByContains(readByJSON, reader string) bool {
    var items []string
    if err := json.Unmarshal([]byte(readByJSON), &items); err != nil {
        return false
    }
    for _, item := range items {
        if item == reader {
            return true
        }
    }
    return false
}
```

**Step 4: Run test to verify it passes**

Run: `go test ./...`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/repo/messages.go internal/repo/messages_test.go
git commit -m "feat: add message repository"
```

---

### Task 6: Implement `otto say`, `otto ask`, `otto complete`

**Files:**
- Create: `internal/cli/commands/say.go`
- Create: `internal/cli/commands/ask.go`
- Create: `internal/cli/commands/complete.go`
- Modify: `internal/cli/root.go`
- Create: `internal/cli/commands/commands_test.go`

**Step 1: Write the failing test**

```go
package commands

import "testing"

func TestAskSetsWaiting(t *testing.T) {
    db := openTestDB(t)
    _ = repo.CreateAgent(db, repo.Agent{ID: "authbackend", Type: "claude", Task: "task", Status: "working"})
    err := runAsk(db, "authbackend", "Question?")
    if err != nil {
        t.Fatalf("ask: %v", err)
    }

    agents, _ := repo.ListAgents(db)
    if agents[0].Status != "waiting" {
        t.Fatalf("expected waiting, got %q", agents[0].Status)
    }
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./...`
Expected: FAIL (runAsk undefined)

**Step 3: Write minimal implementation**

Implement helpers `runSay`, `runAsk`, `runComplete` that accept a `*sql.DB` and do the work. Each command should:
- Generate a UUID for message ID
- Parse `@mentions` from content (regex `@([a-z0-9-]+)`), dedupe, and store as JSON array in `messages.mentions`
- Insert a message with type (`say`, `question`, `complete`)
- Update agent status (`waiting` for ask, `done` for complete)
 - Enforce `--id` is required for agent commands (`say`, `ask`, `complete`)

**Step 4: Run test to verify it passes**

Run: `go test ./...`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/cli/commands/say.go internal/cli/commands/ask.go internal/cli/commands/complete.go internal/cli/commands/commands_test.go internal/cli/root.go
git commit -m "feat: add say/ask/complete commands"
```

---

### Task 7: Implement `otto messages` + `otto status`

**Files:**
- Create: `internal/cli/commands/messages.go`
- Create: `internal/cli/commands/status.go`
- Modify: `internal/cli/root.go`
- Create: `internal/cli/commands/filters_test.go`

**Step 1: Write the failing test**

```go
package commands

import "testing"

func TestParseMessagesFlags(t *testing.T) {
    f := parseMessagesFlags("authbackend", "question", 10, "authbackend")
    if f.FromID != "authbackend" || f.Type != "question" || f.Limit != 10 || f.ReaderID != "authbackend" {
        t.Fatalf("unexpected filter: %#v", f)
    }
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./...`
Expected: FAIL (parseMessagesFlags undefined)

**Step 3: Write minimal implementation**

Add `messages` command that accepts `--from`, `--questions`, `--last`, `--mentions <id>`, and `--id <reader>` (for unread). Default behavior is unread-only with no limit. `--last N` returns last N messages (read + unread). Map these to repo filters and filter unread by checking `read_by` for the reader ID unless `--last` is set. After printing messages for a reader, append the reader ID into `read_by` for those messages (only if not already present). `status` should list agents with statuses.

**Step 4: Run test to verify it passes**

Run: `go test ./...`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/cli/commands/messages.go internal/cli/commands/status.go internal/cli/commands/filters_test.go internal/cli/root.go
git commit -m "feat: add messages and status commands"
```

---

### Task 8: Implement `otto spawn`, `otto prompt`, `otto attach`

**Files:**
- Create: `internal/cli/commands/spawn.go`
- Create: `internal/cli/commands/prompt.go`
- Create: `internal/cli/commands/attach.go`
- Create: `internal/exec/runner.go`
- Create: `internal/cli/commands/spawn_test.go`
- Modify: `internal/cli/root.go`

**Step 1: Write the failing test**

```go
package commands

import "testing"

func TestSpawnBuildsCommand(t *testing.T) {
    cmd := buildSpawnCommand("claude", "task", "sess-123")
    if got := cmd[0]; got != "claude" {
        t.Fatalf("expected claude, got %q", got)
    }
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./...`
Expected: FAIL (buildSpawnCommand undefined)

**Step 3: Write minimal implementation**

- `spawn`: generate agent ID from the task slug (lowercase alphanumeric only, max 16 chars). If the slug exists, append `-2`, `-3`, ... until unique. Create agent row (status `working`), generate session ID (UUID) or store tool-provided session ID when available. Build a spawn prompt that includes the agent communication template (see design doc) before the task. Run `claude -p <prompt> --session-id <id>` or `codex exec <prompt>` (if session ID not supported). If possible, use `codex exec --json` to capture `thread.started.thread_id`. Keep the agent record even if the tool exits and surface the error.
- `prompt`: Claude uses `claude --continue --print "<message>"` as the default automation path; only use `--resume <id> --print` if verified. Codex uses `codex exec resume <session-id> "<message>"`. If no session ID, return a clear error.
- `attach`: print resume command based on agent type and session ID.
- `runner`: wraps `os/exec` for easier test stubbing.
- Enforce `--id` flag: orchestrator commands (`spawn`, `prompt`, `attach`) reject `--id`.

**Step 4: Run test to verify it passes**

Run: `go test ./...`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/cli/commands/spawn.go internal/cli/commands/prompt.go internal/cli/commands/attach.go internal/exec/runner.go internal/cli/commands/spawn_test.go internal/cli/root.go
git commit -m "feat: add spawn, prompt, attach commands"
```

---

### Task 9: Implement `otto watch` (simple polling)

**Files:**
- Create: `internal/cli/commands/watch.go`
- Modify: `internal/cli/root.go`
- Create: `internal/cli/commands/watch_test.go`

**Step 1: Write the failing test**

```go
package commands

import "testing"

func TestWatchSinceID(t *testing.T) {
    next := nextSince("m10")
    if next != "m10" {
        t.Fatalf("unexpected next: %s", next)
    }
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./...`
Expected: FAIL (nextSince undefined)

**Step 3: Write minimal implementation**

Implement `watch` as a loop that fetches messages after the last seen timestamp or ID, prints new ones, and sleeps for a short interval (e.g., 1s). Keep it simple; no TUI.

**Step 4: Run test to verify it passes**

Run: `go test ./...`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/cli/commands/watch.go internal/cli/commands/watch_test.go internal/cli/root.go
git commit -m "feat: add watch command"
```

---

Plan complete and saved to `docs/plans/2025-12-22-otto-v0.md`.

Two execution options:

1) Subagent-Driven (this session) — I dispatch fresh subagent per task, review between tasks, fast iteration
2) Parallel Session (separate) — Open new session with executing-plans, batch execution with checkpoints

Which approach?
